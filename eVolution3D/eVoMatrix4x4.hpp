#pragma once
#include <string.h>
#include "eVoVector3.hpp"

struct eVoMatrix4x4
{
	//---------------------------------------------------------------------------------------------------------

	public:
	float M[4][4]; // Notation M[column][row]
	
	//---------------------------------------------------------------------------------------------------------

	public: eVoMatrix4x4()
	{
		SetIdentity();
	}

	//---------------------------------------------------------------------------------------------------------

	public: void SetZero()
	{
		memset(M, 0, sizeof(M));
	}

	//---------------------------------------------------------------------------------------------------------

	public: void SetIdentity()
	{
		memset(M, 0, sizeof(M));
		M[0][0] = 1;
		M[1][1] = 1;
		M[2][2] = 1;
		M[3][3] = 1;
	}

	//---------------------------------------------------------------------------------------------------------

	public: eVoVector3 operator*(eVoVector3 vector)
	{
		eVoVector3 v;
		v.x = M[0][0] * vector.x + M[1][0] * vector.y + M[2][0] * vector.z + M[3][0];
		v.y = M[0][1] * vector.x + M[1][1] * vector.y + M[2][1] * vector.z + M[3][1];
		v.z = M[0][2] * vector.x + M[1][2] * vector.y + M[2][2] * vector.z + M[3][2];
		return v;
	}

	//---------------------------------------------------------------------------------------------------------

	public: void operator*=(eVoMatrix4x4 m)
	{
		*this = (*this * m);
	}

	//---------------------------------------------------------------------------------------------------------

	public: eVoMatrix4x4 operator*(eVoMatrix4x4 m)
	{
		eVoMatrix4x4 n;

		n.M[0][0] = M[0][0] * m.M[0][0] + M[1][0] * m.M[0][1] + M[2][0] * m.M[0][2] + M[3][0] * m.M[0][3];
		n.M[1][0] = M[0][0] * m.M[1][0] + M[1][0] * m.M[1][1] + M[2][0] * m.M[1][2] + M[3][0] * m.M[1][3];
		n.M[2][0] = M[0][0] * m.M[2][0] + M[1][0] * m.M[2][1] + M[2][0] * m.M[2][2] + M[3][0] * m.M[2][3];
		n.M[2][0] = M[0][0] * m.M[3][0] + M[1][0] * m.M[3][1] + M[2][0] * m.M[3][2] + M[3][0] * m.M[3][3];

		n.M[0][1] = M[0][1] * m.M[0][0] + M[1][1] * m.M[0][1] + M[2][1] * m.M[0][2] + M[3][1] * m.M[0][3];
		n.M[1][1] = M[0][1] * m.M[1][0] + M[1][1] * m.M[1][1] + M[2][1] * m.M[1][2] + M[3][1] * m.M[1][3];
		n.M[2][1] = M[0][1] * m.M[2][0] + M[1][1] * m.M[2][1] + M[2][1] * m.M[2][2] + M[3][1] * m.M[2][3];
		n.M[2][1] = M[0][1] * m.M[3][0] + M[1][1] * m.M[3][1] + M[2][1] * m.M[3][2] + M[3][1] * m.M[3][3];

		n.M[0][2] = M[0][2] * m.M[0][0] + M[1][2] * m.M[0][1] + M[2][2] * m.M[0][2] + M[3][2] * m.M[0][3];
		n.M[1][2] = M[0][2] * m.M[1][0] + M[1][2] * m.M[1][1] + M[2][2] * m.M[1][2] + M[3][2] * m.M[1][3];
		n.M[2][2] = M[0][2] * m.M[2][0] + M[1][2] * m.M[2][1] + M[2][2] * m.M[2][2] + M[3][2] * m.M[2][3];
		n.M[2][2] = M[0][2] * m.M[3][0] + M[1][2] * m.M[3][1] + M[2][2] * m.M[3][2] + M[3][2] * m.M[3][3];

		n.M[0][3] = M[0][3] * m.M[0][0] + M[1][3] * m.M[0][1] + M[2][3] * m.M[0][2] + M[3][3] * m.M[0][3];
		n.M[1][3] = M[0][3] * m.M[1][0] + M[1][3] * m.M[1][1] + M[2][3] * m.M[1][2] + M[3][3] * m.M[1][3];
		n.M[2][3] = M[0][3] * m.M[2][0] + M[1][3] * m.M[2][1] + M[2][3] * m.M[2][2] + M[3][3] * m.M[2][3];
		n.M[2][3] = M[0][3] * m.M[3][0] + M[1][3] * m.M[3][1] + M[2][3] * m.M[3][2] + M[3][3] * m.M[3][3];

		return n;
	}

	//---------------------------------------------------------------------------------------------------------
};